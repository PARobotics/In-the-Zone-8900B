#pragma config(Sensor, in1,    POT_SENSOR,     sensorPotentiometer)
#pragma config(Sensor, dgtl2,  LIM_SWITCH,     sensorTouch)
#pragma config(Motor,  port1,           mobile_goal_lift_1, tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port6,           wheel_LF,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           wheel_LB,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           wheel_RF,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           wheel_RB,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          mobile_goal_lift_2, tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// ** Motor and Sensor Setup **

#pragma platform(VEX)
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(1200)
#include "Vex_Competition_Includes.c"

#include "auton.c"
#include "parallax-library/main.c"

/*
  Pre-autonomous
*/

void pre_auton(){
  bStopTasksBetweenModes = false;
  initialize();
}

/*
 	Autonomous
*/

task autonomous(){
  stopTask(usercontrol);
	autonProcedure();
}

/*
	USER CONTROL
*/

task usercontrol(){
  stopTask(autonomous);

  int V, H;

  while(true){
		V = vexRT[Ch2];
		H = vexRT[Ch1];

		move(V, H*0.75, 0);

		if (vexRT[Btn7U] == 1) {

			while (sensorValue(LIM_SWITCH) != 1) {
				// move up
				motor[mobile_goal_lift_1] = -127;
				motor[mobile_goal_lift_2] = -127;
			}
			motor[mobile_goal_lift_1] = 0;
			motor[mobile_goal_lift_2] = 0;
		}

		if (vexRT[Btn7D] == 1) {

			while (sensorValue(POT_SENSOR) < 2700) {
				// move down
				motor[mobile_goal_lift_1] = 127;
				motor[mobile_goal_lift_2] = 127;
			}

			motor[mobile_goal_lift_1] = 0;
			motor[mobile_goal_lift_2] = 0;
		}

		/* Moving Mobile Goal down with Cones
		else if(MOBILE_GOAL_COMMAND == DOWN){ //Automatically lowers mobile goal stack into place

      t0 = time1[T1];

      moveMobileGoalLift(DOWN);

      updateSensor(&mobileGoalLift);



	      while(!isTimedOut(t0 + 2500) && !isBailedOut() && mobileGoalLift.val > MOBILE_GOAL_BOTTOM_LIMIT){

	      	updateSensor(&mobileGoalLift);

	      	mobileGoalAppliedVoltage = sensorHold(&mobileGoalLift, MOBILE_GOAL_BOTTOM_LIMIT, MOBILE_GOAL_DEFAULT_V, MOBILE_GOAL_MIN_V, MOBILE_GOAL_MAX_V);

	      	if(mobileGoalLift.val > 1600) mobileGoalAppliedVoltage -= 20; //Push the goal down to the ground at the end

	     		moveMobileGoalLift(mobileGoalAppliedVoltage);



					#if DEBUG_MOBILE_GOAL == 1

						writeDebugStreamLine("[MOBILE_GOAL] %d %d %d %d %d", time1[T1] - t0, MOBILE_GOAL_BOTTOM_LIMIT, mobileGoalLift.val, mobileGoalLift.speed, mobileGoalAppliedVoltage);

					#endif



	        wait1Msec(10);

	      }



      coneNum = 0;

      moveMobileGoalLift(STOP);

      MOBILE_GOAL_COMMAND = STOP;

    }

    else if(MOBILE_GOAL_COMMAND == DOWN_WITHOUT_GOAL){ //Pushes the lift to ground if it doesn't have a mobile goal

      t0 = time1[T1];

      moveMobileGoalLift(DOWN);

      updateSensorValue(&mobileGoalLift);

      while(!isTimedOut(t0 + 2500) && !isBailedOut() && mobileGoalLift.val > MOBILE_GOAL_BOTTOM_LIMIT){

      	updateSensorValue(&mobileGoalLift);

        moveMobileGoalLift(DOWN);

        wait1Msec(10);

      }
*/

    userControlUpdate();
  }
}
